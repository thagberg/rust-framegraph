06 July 2022 - Refreshing my memory on a lot of things. I had been working on the
shader cache, but it took me a while to figure out why I was working on that.
Currently, recreating the graph nodes is leaking descriptor sets and eventually 
will cause a panic when unble to allocate more. The new ShaderModule type uses 
SPIR-V reflection to build descriptor sets, descriptor set layouts, and the
pipeline layout, all of which are cached.

16 July 2022 - Should look into standardizing the various state objects which
comprise the graphics pipeline:
	* rasterizer
	* depth / stencil
	* viewport
	* multisample
	* blend
	* dynamic state
If I do that then I can simply provide a string of a pipeline for a pass as well
as the inputs / outputs and then the framegraph can fetch a cached graphics pipeline
and provide that to the pass callback.

19 July 2022 - Need to refactor the Framegraph and how PassNodes are created.
A PassNode should now be constructed with a PipelineDescription rather than
creating the pipeline itself. Then if a node is preserved by the framegrpah,
the framegraph will go to the PipelineManager to either create a pipeline or
use a cached one. During node execution it should only require the handle for
a pipeline (which includes the shaders used).

UBO Pass currently looks like this:
* Create renderpass
* Create Pipeline
* Create PassNode 
	* Pass Pipeline to PassNode -- nothing is done with it here
	* Pass pipeline layout from shader module
* Execution
	* Get rendertarget and UBO buffer from resolved resources passed in by framegraph
	* Prepare descriptor writes
	* Prepare viewport / scissor structs
	* Set viewport / scissor
	* Begin renderpass
	* Bind pipeline
	* Update descriptors
	* Bind descriptors
	* Execute draw calls
	* End renderpass

After refactoring it should look more like this:
* Create PassNode
	* Pass PipelineDescription
	* Pass inputs / outputs
	* Framegraph uses PipelineDescription and inputs / outputs to generate renderpass
		(or subpass potentially?)
	* Framegraph uses PipelineDescription to either generate pipeline or fetch from cache
* Framegraph calls node execute
	* Get resolved resources
	* Prepare descriptor writes
	* Set viewport / scissor (maybe can remove this?)
	* Begin renderpass -- passed into execute callback, maybe the framegraph should handle this?
	* Bind pipeline -- handle passed into execute callback
	* Update descriptors
	* Bind descriptors
	* Execute draw calls
	* End renderpass (?)

20 July 2022 - Considering a new "rendertarget" attachment type for PassNode. This
would allow the framegraph to handle creating the framegraph object for a pass. That
would then also allow the framegraph to handle beginning and ending the renderpass.

Also starting to think about how to move descriptor updates out of the PassNode
callback. Descriptor set layouts are available in reflection data from the shader.
Could either match on name or just enforce the order that writes/reads are provided
to the PassNode builder. This would also probably necessitate the "rendertarget"
attachment type being separated from write attachments, as those will not be touched
by a descriptor update.

23 July 2022 - The Framegraph needs to generate renderpasses so that it can verify
that edges in the graph are valid and so that it can provide it to the
PipelineManager when fetching or generating the pipeline for a pass. Potentially
the Framegraph can inspect the graph during a compile/link phase to determine when 
and where subpasses are appropriate rather than an entire new renderpass.
