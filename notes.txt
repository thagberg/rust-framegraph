06 July 2022 - Refreshing my memory on a lot of things. I had been working on the
shader cache, but it took me a while to figure out why I was working on that.
Currently, recreating the graph nodes is leaking descriptor sets and eventually 
will cause a panic when unble to allocate more. The new ShaderModule type uses 
SPIR-V reflection to build descriptor sets, descriptor set layouts, and the
pipeline layout, all of which are cached.

16 July 2022 - Should look into standardizing the various state objects which
comprise the graphics pipeline:
	* rasterizer
	* depth / stencil
	* viewport
	* multisample
	* blend
	* dynamic state
If I do that then I can simply provide a string of a pipeline for a pass as well
as the inputs / outputs and then the framegraph can fetch a cached graphics pipeline
and provide that to the pass callback.

19 July 2022 - Need to refactor the Framegraph and how PassNodes are created.
A PassNode should now be constructed with a PipelineDescription rather than
creating the pipeline itself. Then if a node is perserved by the framegrpah,
the framegraph will go to the PipelineManager to either create a pipeline or
use a cached one. During node execution it should only require the handle for
a pipeline (which includes the shaders used).

UBO Pass currently looks like this:
* Create renderpass
* Create Pipeline
* Create PassNode 
	* Pass Pipeline to PassNode -- nothing is done with it here
	* Pass pipeline layout from shader module
* Execution
	* Get rendertarget and UBO buffer from resolved resources passed in by framegraph
	* Prepare descriptor writes
	* Prepare viewport / scissor structs
	* Set viewport / scissor
	* Begin renderpass
	* Bind pipeline
	* Update descriptors
	* Bind descriptors
	* Execute draw calls
	* End renderpass

After refactoring it should look more like this:
* Create PassNode
	* Pass PipelineDescription
	* Pass inputs / outputs
	* Framegraph uses PipelineDescription and inputs / outputs to generate renderpass
		(or subpass potentially?)
	* Framegraph uses PipelineDescription to either generate pipeline or fetch from cache
* Framegraph calls node execute
	* Get resolved resources
	* Prepare descriptor writes
	* Set viewport / scissor (maybe can remove this?)
	* Begin renderpass -- passed into execute callback, maybe the framegraph should handle this?
	* Bind pipeline -- handle passed into execute callback
	* Update descriptors
	* Bind descriptors
	* Execute draw calls
	* End renderpass (?)
