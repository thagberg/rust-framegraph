06 July 2022 - Refreshing my memory on a lot of things. I had been working on the
shader cache, but it took me a while to figure out why I was working on that.
Currently, recreating the graph nodes is leaking descriptor sets and eventually 
will cause a panic when unble to allocate more. The new ShaderModule type uses 
SPIR-V reflection to build descriptor sets, descriptor set layouts, and the
pipeline layout, all of which are cached.

16 July 2022 - Should look into standardizing the various state objects which
comprise the graphics pipeline:
	* rasterizer
	* depth / stencil
	* viewport
	* multisample
	* blend
	* dynamic state
If I do that then I can simply provide a string of a pipeline for a pass as well
as the inputs / outputs and then the framegraph can fetch a cached graphics pipeline
and provide that to the pass callback.

19 July 2022 - Need to refactor the Framegraph and how PassNodes are created.
A PassNode should now be constructed with a PipelineDescription rather than
creating the pipeline itself. Then if a node is preserved by the framegrpah,
the framegraph will go to the PipelineManager to either create a pipeline or
use a cached one. During node execution it should only require the handle for
a pipeline (which includes the shaders used).

UBO Pass currently looks like this:
* Create renderpass
* Create Pipeline
* Create PassNode 
	* Pass Pipeline to PassNode -- nothing is done with it here
	* Pass pipeline layout from shader module
* Execution
	* Get rendertarget and UBO buffer from resolved resources passed in by framegraph
	* Prepare descriptor writes
	* Prepare viewport / scissor structs
	* Set viewport / scissor
	* Begin renderpass
	* Bind pipeline
	* Update descriptors
	* Bind descriptors
	* Execute draw calls
	* End renderpass

After refactoring it should look more like this:
* Create PassNode
	* Pass PipelineDescription
	* Pass inputs / outputs
	* Framegraph uses PipelineDescription and inputs / outputs to generate renderpass
		(or subpass potentially?)
	* Framegraph uses PipelineDescription to either generate pipeline or fetch from cache
* Framegraph calls node execute
	* Get resolved resources
	* Prepare descriptor writes
	* Set viewport / scissor (maybe can remove this?)
	* Begin renderpass -- passed into execute callback, maybe the framegraph should handle this?
	* Bind pipeline -- handle passed into execute callback
	* Update descriptors
	* Bind descriptors
	* Execute draw calls
	* End renderpass (?)

20 July 2022 - Considering a new "rendertarget" attachment type for PassNode. This
would allow the framegraph to handle creating the framegraph object for a pass. That
would then also allow the framegraph to handle beginning and ending the renderpass.

Also starting to think about how to move descriptor updates out of the PassNode
callback. Descriptor set layouts are available in reflection data from the shader.
Could either match on name or just enforce the order that writes/reads are provided
to the PassNode builder. This would also probably necessitate the "rendertarget"
attachment type being separated from write attachments, as those will not be touched
by a descriptor update.

23 July 2022 - The Framegraph needs to generate renderpasses so that it can verify
that edges in the graph are valid and so that it can provide it to the
PipelineManager when fetching or generating the pipeline for a pass. Potentially
the Framegraph can inspect the graph during a compile/link phase to determine when 
and where subpasses are appropriate rather than an entire new renderpass.

25 July 22 - Consider refactoring FrameGraph to own PassNodes rather than have
references to them

Also consider making the FrameGraph own the ResourceManager...
This would make it easier for the FrameGraph to reason about transient resources

Build DAG

Filter leaf nodes to only those with backbuffer as output

Topological sort?

07 August 22 - Start designing RenderpassManager.
During framegraph compilation, a renderpass will be generated / fetched for each
accepted node.

Cached base on pipeline name?

Inputs: rendertargets and read images
Rendertargets always used, read images only if this is a subpass... Put this off for later probably
Eventually can look for subpass candidates

21 August 22 - Time to think about global resources and resource lifetimes
Refcounted resources - how do we clean up the resource via Drop trait?
	Need to free allocation on the Allocator
	Need to destroy resource on the Device

Transient resources
	After frame submission, put all transient resources into deletion queue
	Once we know the GPU is done, flush the deletion queue
	
Global resources
	Owner registers the global resource with resource manager
	Allocation is created
	Owner tells resource manager to delete global resource
	What if it doesn't?
	How will the owner get a mutable ref to the resource manager when it needs to clean up?

02 September 22 - Considering additional PassNode resource types
	Currently have Input, Output, RenderTarget
	Add TransferSrc and TransferDst
		This will support blits and copies without the pass needing to handle transitions
	How will the framegraph know the previos resource state to transition from?
		Resource manager could track current resource state
		Or maybe just add this to the ResourceHandle?

06 October 22 - Current Layout is added to ImageWrapper
	Next, framegraph should use this to handle layout transitions between nodes
	Add copy src/dst inputs to PassNode
	Framegraph can then use those to perform the correct transition in a pipeline barrier
	Example of copy:
		Blit specifies a texture as a CopySrc and swapchain image as CopyDst
		Framegraph uses texture's current layout -> TRANSFER_SRC
		Framegraph uses swapchain image's current layout -> TRANSFER_DST
	Example of read after write on image:
		Pass specifies a texture as an read dependency and a rendertarget as a write dependency
		Texture current layout -> READ_ONLY_OPTIMAL
		Rendertarget current layout -> COLOR_ATTACHMENT_OPTIMAL	

16 October 22 - Consider removing all function calls on ash::Device from code
	outside of DeviceWrapper implementation.
	e.g. instead of calling `render_ctx.get_device().get().create_graphics_pipeline(...)` I should
	implement a `create_graphics_pipeline` on the DeviceWrapper (or something similar)
